---
title: SQL Transactions
---

:icon: /images/icons
:clojure: /drivers/clojure/sql.html#txs
:kotlin: /drivers/kotlin/kdoc/xtdb-api/xtdb.api/-i-xtdb/execute-tx.html

[.lang-icons.right]
image:{icon}/clojure.svg[Clojure,link={clojure}]
image:{icon}/kotlin.svg[Kotlin,link={kotlin}]

For examples on how to submit SQL transactions in each client library, see the individual driver documentation:

[#tx-ops]
== Transaction operations

=== `INSERT`

Inserts documents into a table.

[railroad]
----
const insertIntoTable = rr.Sequence("INSERT", "INTO", "<table name>")
const colNames = rr.Sequence("(", rr.OneOrMore("<column name>", ","), ")")
const doc = rr.Sequence("(", rr.OneOrMore("<value>", ","), ")")
const docs = rr.OneOrMore(doc, ",")
const values = rr.Sequence(colNames, "VALUES", docs)
const selectQuery = rr.Sequence(rr.Optional(colNames, "skip"), "<select query>")
return rr.Diagram(rr.Stack(insertIntoTable, rr.Choice(0, values, selectQuery)))
----

* Documents must contain an `_id` column.
* By default, the document will be inserted for valid-time between now and end-of-time.
  This can be overridden by including `_valid_from` and/or `_valid_to` columns in the document.
* If the document already exists, 'insert' behaves like an upsert - it will overwrite the existing document for the valid-time range specified (or now -> end-of-time if not provided).


=== `UPDATE`

Updates documents in a table, optionally for a period of valid-time.

[railroad]
----
const updateTable = rr.Sequence("UPDATE", "<table name>")
const forValidTime = rr.Choice(0,
  rr.Sequence("FOR", "PORTION", "OF", "VALID_TIME", "FROM", "<timestamp>", "TO", "<timestamp>"),
  rr.Sequence("FOR", "ALL", "VALID_TIME"),
  rr.Sequence("FOR", "VALID_TIME", "ALL"))
const setClause = rr.Sequence("SET", rr.OneOrMore(rr.Sequence("<column>", "=", "<value>"), ","))
const predicate = rr.Optional(rr.Sequence("WHERE", "<predicate>"), "skip")
return rr.Diagram(rr.Stack(updateTable, rr.Optional(forValidTime, "skip"), rr.Sequence(setClause, predicate)))
----

* If the valid-time range is not provided, the effective valid-time range of the update will be from now to the end of time.
  (SQL:2011 specifies that updates without this clause should be effective for all valid time; the now->end-of-time default is an XTDB deviation.)
* The `_id` column cannot be updated - instead, users should delete this document and re-insert a new one.
* The valid-time columns cannot be updated outside of the for-valid-time clause (i.e. not in the `SET` clause).


=== `DELETE`

Deletes documents from a table, optionally for a period of valid-time.

[railroad]
----
const deleteTable = rr.Sequence("DELETE", "FROM", "<table name>")
const forValidTime = rr.Choice(0,
  rr.Sequence("FOR", "PORTION", "OF", "VALID_TIME", "FROM", "<timestamp>", "TO", "<timestamp>"),
  rr.Sequence("FOR", "ALL", "VALID_TIME"),
  rr.Sequence("FOR", "VALID_TIME", "ALL"))
const predicate = rr.Optional(rr.Sequence("WHERE", "<predicate>"), "skip")
return rr.Diagram(rr.Stack(deleteTable, rr.Optional(forValidTime, "skip"), predicate))
----

* If the valid-time clause is not provided, the effective valid-time range of the delete will be from now to the end of time.
  (SQL:2011 specifies that deletes without this clause should be effective for all valid time; the now->end-of-time default is an XTDB deviation.)

=== `ERASE`

Irrevocably erases documents from a table, for all valid-time, for all system-time.

While XTDB is immutable, in some cases it is legally necessary to irretrievably delete data (e.g. for a GDPR request).
This operation removes data such that even queries as of a previous system-time no longer return the erased data.

[railroad]
----
const eraseTable = rr.Sequence("ERASE", "FROM", "<table name>")
const predicate = rr.Optional(rr.Sequence("WHERE", "<predicate>"), "skip")
return rr.Diagram(rr.Stack(eraseTable, predicate))
----

=== `ASSERT`

Rolls back the transaction if the provided predicate is false.

This is used to enforce constraints on the data in a concurrent environment, such as ensuring that a document with a given ID does not already exist.

[railroad]
----
return rr.Diagram("ASSERT", "<predicate>")
----

* We check to see whether the email address already exists in the database - if not, we can insert the new user.
+
[source,sql]
----
ASSERT NOT EXISTS (SELECT 1 FROM users WHERE email = 'james@example.com')

INSERT INTO users (_id, name, email) VALUES ('james', 'James', 'james@example.com')
----
* Check the `xt.txs` table for the transaction result to see if the assertion failed.
+
[source,sql]
SELECT * FROM xt.txs;
+
[source,text]
----
 _id  | committed |            error              |          system_time
------+-----------+-------------------------------+-------------------------------
    0 | t         | null                          | "2024-06-25T16:45:16.492255Z"
    1 | t         | null                          | "2024-06-25T16:45:26.985539Z"
    2 | f         | ... "Precondition failed" ... | "2024-06-25T16:45:32.577224Z"
(3 rows)
----
