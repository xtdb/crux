= XTQL Queries

XTQL queries are submitted through `xtdb.api/q`

* `(xt/q <node> '<query> <opts>?)` returns the query results as a vector of maps.
* `(xt/q& <node> '<query> <opts>?)`: returns a `CompletableFuture` of the query results.

XTQL query options are an optional map of the following keys:

* `:args`: a map of arguments to pass to the query. Parameters are prefixed with `$` in the query itself:
+
[source,clojure]
----
(xt/q node '(from :users [{:username $username}])
      {:args {:username "james"}})
----
+
* `:basis`: a map specifying the 'basis' of the query - this is used to ensure repeatable queries.
** `:tx`: specifies the latest transaction that'll be visible to the query
** `:after-tx`: requires that the node has indexed at least the specified transaction.
+
If it's not provided, the XTDB client will default it to the latest transaction submitted through that client, in order to 'read your writes'.
** `:current-time`: overrides the wall-clock time used in any functions that require it.
* `:default-tz`: the default timezone to use - defaults to the JVM timezone of the server.
* `:explain?`: rather than returning results, setting this flag to `true` returns the query plan for the query - defaults to `false`.
* `:key-fn`: specifies how keys are returned in query results.
** `:clojure` (default): kebab-case, dot-namespaced keywords (e.g. `:foo.bar/baz-quux`)

XTQL queries consist of composable operators, optionally combined with a pipeline.

* 'Source operators' are valid at the start of a pipeline, or in isolation.
* 'Tail operators' transform data in a pipeline - they aren't valid as the first operator, because they don't source data, but can appear anywhere else in the pipeline.

A pipeline consists of a source operator, and optionally many tail operators:

[source,clojure]
----
(-> (from ...) ; source
    (order-by ...) ; tail
    (limit ...) ; tail
    )

;; unlike in Clojure, XTQL's `->` isn't a threading macro
;; - just the symbol for a pipeline of operations.
----

Pipelines are optional - queries with just a source operator (i.e. no tails) can be submitted simply as:

[source,clojure]
----
(from ...)
----

The operators are as follows:

.Source operators
[cols="3,8"]
|===
|Operator|Purpose

| link:#_from[`from`,role=no-underline] | Sources data from a table in XTDB
| link:#_table[`table`,role=no-underline] | Sources data from the user-specified relation
| link:#_unify[`unify`,role=no-underline] | Combines multiple input sources using Datalog-style unification.
|===

.Tail operators
[cols="3,8"]
|===
|Operator|Purpose

| link:#_aggregate[`aggregate`,role=no-underline] | Groups the relation rows by the given aggregate-specs
| link:#_limit[`limit`,role=no-underline] | Only returns the top N rows of the relation
| link:#_offset[`offset`,role=no-underline] | Skips the first N rows of the relation
| link:#_order-by[`order-by`,role=no-underline] | Orders the relation by the given columns
| link:#_return[`return`,role=no-underline] | Restricts the output to the given columns
| link:#_where[`where`,role=no-underline] | Filters the relation using the given predicates
| link:#_with[`with`,role=no-underline] | Adds columns to the relation
| link:#_without[`without`,role=no-underline] | Removes columns from the relation
| link:#_unnest[`unnest`,role=no-underline] | Flattens an array within a column into individual rows
|===

Joins in XTQL are specified using the link:#_unify[`unify`] operator - this combines multiple input relations using Datalog-style unification.
This allows for very declarative yet terse method of specifying join conditions; how relations relate to each other.

'Unify clauses' are inputs to the link:#_unify[`unify`,role=no-underline] operator:

.Unify clauses
[cols="3,8"]
|===
|Clause|Purpose

| link:#_from[`from`,role=no-underline] | Sources data from a table in XTDB.
| link:#_joins[`join`,role=no-underline] | Further constrains the unification using the given query
| link:#_joins[`left-join`,role=no-underline] | Optionally joins the unification against the given query
| link:#_table[`table`,role=no-underline] | Sources data from the user-specified relation.
| link:#_where[`where`,role=no-underline] | Filters the rows using the given predicates
| link:#_with[`with`,role=no-underline] | Defines new logical variables in the unification
|===

== Operators

=== `aggregate`

The `aggregate` operator aggregates rows in a query according to the aggregate specs.

[source]
----
Aggregate :: (aggregate AggSpec*)

AggSpec :: GroupingVar | {Column Expr, ...}

GroupingVar :: symbol
Column :: keyword

Expr :: <defined separately>
----

For example:

[source,clojure]
----
(-> (unify (from :customers [{:xt/id customer-id, :name customer-name}])
           (from :orders [customer-id order-value]))
    (aggregate customer-id customer-name
               {:order-count (count-star)
                :total-value (sum order-value)})
    (order-by {:val total-value, :dir :desc})
    (limit 10)
    (without :customer-id))
----

The available aggregate functions are documented link:../stdlib/aggregates[here].

=== `from`

The `from` operator sources data from a table in XTDB - it expects the table to fetch from, as well as options that define what columns to return, as well as any temporal filters to apply.

[source]
----
From :: (from Table FromOpts)
Table :: keyword

FromOpts :: [BindSpec+]
            | {; required
               :bind [BindSpec+]

               ; optional
               :for-valid-time TemporalFilter
               :for-system-time TemporalFilter}

TemporalFilter :: (at Timestamp)
                | (from Timestamp)
                | (to Timestamp)
                | (in Timestamp Timestamp)
                | :all-time

Timestamp :: java.util.Date | java.time.Instant | java.time.ZonedDateTime
----

The binding specs define which columns are retrieved from the table, and specify constraints on those columns.
For more details, see the link:#_binding_specs[binding specs] section.

For example:

[source,clojure]
----
;; `SELECT username, first_name, last_name FROM users`
(from :users [username first-name last-name])

;; `SELECT username AS login, first_name, last_name FROM users`
(from :users [{:username login} first-name last-name])

;; `SELECT first_name, last_name FROM users WHERE username = 'james'`
(from :users [{:username "james"} first-name last-name])

;; `SELECT first_name, last_name FROM users WHERE username = ?`
(from :users [{:username $username} first-name last-name])
----

==== Temporal filters

Temporal filters control the document versions that are visible to the query.

* `(at <timestamp>)`: rows that were/will be visible at the specified timestamp - i.e. `+row-from <= timestamp < row-to+`
* `(from <timestamp>)`: rows that have been visible any time after the timestamp - i.e. `+row-to > timestamp+`
* `(to <timestamp>)`: rows that were visible any time before the timestamp - i.e. `+row-from < timestamp+`
* `(in <from-timestamp> <to-timestamp>)`: rows that were visible any time within the period - i.e. `+row-to > <from-timestamp> && row-from < <to-timestamp>+`
* `:all-time`: all rows, throughout history.

Unless otherwise specified, queries will see the current version of the row, `(at <now>)`, in both valid time and system time.

For example:

[source,clojure]
----
(from :users {:bind [...]
              :for-valid-time (in #inst "2020-01-01" #inst "2021-01-01")
              :for-system-time (at #inst "2023-01-01")}
----

Without any temporal filters, it is valid to just specify the binding specs without a map.

[#_joins]
=== Joins - `join`, `left-join`

The `join` and `left-join` unify clauses further constrain a unification by joining against the given query.

[source]
----
Join :: (join Query JoinOpts)
LeftJoin :: (left-join Query JoinOpts)

JoinOpts :: [BindSpec+]
          | {; required
             :bind [BindSpec+]

             ; optional
             :args [ArgSpec+]}
----

We join the inner query to the rest of the unify inputs using the binding specs - see the link:#_binding_specs[binding specs] section for more details.
These binding specs act as both 'join conditions' (if the logic variables are reused within the unify operator) and a specification of which columns from the sub-query should be returned from the outer query.

* The `join` operator performs an inner, or required, join with the sub-query - if a row from the outer query doesn't match, it won't be returned
* The `left-join` operator performs an outer, or optional, join with the sub-query - if a row from the outer query matches, it'll be returned; if it doesn't, it will still be returned, but with null values in the sub-query columns.

Parameters in the sub-query can be fulfilled with the `:args` option - see the link:#_argument_specs[argument specs] section for more details.

For example:

[source,clojure]
----
(unify (from :customers [{:xt/id customer-id} customer-name]
       (left-join (from :orders [{:xt/id order-id}, customer-id, order-value])
                  [customer-id order-id order-value])))
----

In this case, `customer-id` is specified multiple times, so this adds a join-condition constraint; `order-id` and `order-value` are not specified elsewhere within the unify, so these columns are simply returned.

=== `limit`

The `limit` operator limits the rows returned by the query.
Without an explicit preceding `order-by`, the rows selected for return are undefined.

[source]
----
Limit :: (limit LimitN)
LimitN :: non-negative integer
----

For example:

[source,clojure]
----
(-> (from :users [username])
    (order-by username)
    (limit 10))
----

=== `offset`

The `offset` operator skips the first N rows that would have otherwise been returned by the query.
Without an explicit preceding `order-by`, the rows selected for return are undefined.

[source]
----
Offset :: (offset OffsetN)
OffsetN :: non-negative integer
----

For example:

[source,clojure]
----
(-> (from :users [username])
    (order-by username)
    (offset 10)
    (limit 10))
----

=== `order-by`

The `order-by` operator sorts the rows in a relation.

[source]
----
OrderBy :: (order-by OrderSpec+)
OrderSpec :: OrderCol
           | {; required
              :val Expr

              ; optional
              :dir Direction
              :nulls NullOrdering}

OrderCol :: symbol
Direction :: :asc | :desc
NullOrdering :: :first | :last
Expr :: <defined separately>
----

For example:

[source,clojure]
----
;; sort by order-value descending, then received-at ascending
(-> (from :orders [order-value received-at])
    (order-by {:val order-value, :dir :desc}
              received-at))
----

* `NullOrdering` is not yet implemented in XTQL.

=== `return`

The `return` operator specifies the columns to return from the query.
It also allows additional projections, should you want to return a new column based on existing columns.

[source]
----
Return :: (return ReturnSpec*)
ReturnSpec :: ReturnVar | {Column Expr, ...}
ReturnVar :: symbol
Column :: keyword
Expr :: <defined separately>
----

For example:

[source,clojure]
----
(-> (from :users [username first-name last-name])
    (return username {:full-name (concat last-name ", " first-name)}))

;; =>

[{:username "...", :full-name "..."}
 ...]
----

=== `table`

The `table` operator creates an inline table with the provided values.
It takes an array of maps, either as a literal, a parameter, or a value nested within another document, and yields each element as a row, with the values in the map bound/constrained as required.

[source]
----
Table :: (table TableExpr [BindSpec+])
TableExpr :: Expr

Expr :: <defined separately>
----

For example:

[source,clojure]
----
;; as a literal
(table [{:a 1, :b 2}, {:a 3, :b 4}])

;; from a parameter
(xt/q node '(table $t [a b])
      {:args {:t [{:a 1, :b 2}, {:a 3, :b 4}]}})

;; from a value in another document
;; assume we have a document {:xt/id <id>, :my-nested-table [{:a 1, :b 2}, ...]}
(-> (from :docs [my-nested-table])
    (table my-nested-table [a b]))

;; same, but within a `unify`
(unify (from :docs [my-nested-table])
       (table my-nested-table [a b]))
----

=== `unify`

The `unify` operator combines multiple input relations using Datalog-style unification, to achieve join-like behaviour.

[source]
----
Unify :: (unify UnifyClause+)
UnifyClause :: From | Join | LeftJoin | Table | Where | With
----

Each input relation defines a set of 'logic variables' in its binding specs - if a logic variable appears more than once within a single `unify` operator, the results are constrained such that the logic variable has the same value everywhere it's used.
This has the effect of imposing 'join conditions' over the inputs.

For example:

[source,clojure]
----
(unify (from :customers [{:xt/id customer-id} customer-name])
       (from :orders [{:xt/id order-id} customer-id order-value]))
----

Because this query uses the `customer-id` logic variable twice, we add a constraint that the two occurrences must be equal - it's therefore equivalent to the following SQL:

[source,sql]
----
SELECT c.xt$id AS customer_id, customer_name,
       o.xt$id AS order_id, o.order_value
FROM customers c
  JOIN orders o ON (c.xt$id = o.customer_id)
----

* Join and Left Join clauses work in a similar way to `from`, except they execute a full sub-query rather than reading a single table. Any logic variables specified in their binding specs are unified in the same way.
* Table clauses, likewise - any logic variables specified in its binding specs are unified.
* `where` clauses further constrain the results using predicates - these have access to any logic variable bound in the containing `unify` operator.
* `with` clauses within `unify` may define additional logic variables or, if these logic variables are used elsewhere, again, the value of the `with` result must agree with the value elsewhere in the `unify`.
* The `unify` operator returns a relation containing a column for every logic variable bound in any of its clauses.

=== `unnest`

The `unnest` operator extracts values from an array - returning one row for each element.
The other columns in the query are duplicated for each row.

[source]
----
Unnest :: (unnest UnnestSpec)

; as a tail operator
UnnestSpec :: {Column Expr}
Column :: keyword

; in `unify`
UnnestSpec :: {LogicVar Expr}
LogicVar :: symbol

Expr :: <defined separately>
----

* If the value in question isn't an array, or the array is empty, the row is filtered out.

For example:

[source,clojure]
----
;; as a 'tail' operator - N.B. `:tag` is a column being added
(-> (from :posts [{:xt/id post-id} tags])
    (unnest {:tag tags}))

;; in `unify` - N.B. `tag` is a logic var being introduced
(unify (from :posts [{:xt/id post-id} tags])
       (unnest {tag tags}))

;; =>

[{:post-id 1, :tag "sport"}
 {:post-id 1, :tag "formula-1"}
 {:post-id 2, :tag "health"}
 {:post-id 4, :tag "technology"}
 {:post-id 4, :tag "ai"}
 {:post-id 4, :tag "politics"}]
----

=== `where`

The `where` operator filters rows in a query or unification operator.
It expects (optionally) many predicates - rows that match all of the predicates will be returned; rows that fail to match one or more will be filtered out.

[source]
----
Where :: (where Expr*)

Expr :: <defined separately>
----

* Like all other XTQL expressions, `where` respects 'three-valued logic' - if an expression returns either false or null, the row will be filtered out.
* `where` is short-circuiting - if an earlier predicate doesn't return true for a row, the remaining predicates won't be evaluated.

Example:

[source,clojure]
----
;; as a 'tail' operator
(-> (from :users [username date-of-birth])
    (where (> (current-timestamp)
              (+ date-of-birth #time/period "P18Y"))))

;; in `unify`
(unify (from :customers [{:xt/id customer-id} customer-name vip?])
       (from :orders [{:xt/id order-id} customer-id order-value])
       (where (or vip? (> order-value 1000000))))
----

=== `with`

The `with` operator specifies columns to add to the query.

[source]
----
With :: (with WithSpec*)

; as a tail operator
WithSpec :: WithVar | {Column Expr, ...}

; in `unify`
WithSpec :: WithVar | {LogicVar Expr, ...}

WithVar :: symbol
Column :: keyword
LogicVar :: symbol

Expr :: <defined separately>
----

For example:

[source,clojure]
----
;; as a 'tail' operator - N.B. `:full-name` is a column here
(-> (from :users [username first-name last-name])
    (with {:full-name (str last-name ", " first-name)}))

;; in 'unify' - N.B. `full-name` is a logic variable here
(unify (from :users [username first-name last-name])
       (with {full-name (str last-name ", " first-name)}))

;; =>

[{:username "...", :first-name "...", :last-name "...", :full-name "..."}
 ...]
----

=== `without`

The `without` operator removes columns from the ongoing query:

[source]
----
Without :: (without Column*)
Column :: keyword
----

For example, in this query, we only want the `customer-id` to join on - we don't want it returned - so we exclude it in a `without` operator.

[source,clojure]
----
(-> (unify (from :customers [{:xt/id customer-id}, customer-name])
           (from :orders [customer-id order-value]))
    (without :customer-id))
----

== Expressions

XTQL expressions are valid within predicates, projections, bindings and arguments.

[source]
----
Expr :: number | "string" | true | false | nil | ObjectExpr
      | SetExpr | [Expr*] | {MapKey Expr, ...}
      | ParamExpr | VariableExpr
      | GetFieldExpr | CallExpr
      | SubqueryExpr | ExistsExpr | PullExpr | PullManyExpr

ObjectExpr :: java.time.Temporal | java.time.TemporalAmount

SetExpr :: #{Expr*}
VectorExpr :: [Expr*]
MapExpr :: {MapKey Expr, ...}
MapKey :: keyword

ParamExpr :: '$' symbol
VariableExpr :: symbol
GetFieldExpr :: (. Expr symbol)
CallExpr :: (symbol Expr*)

SubQueryExpr :: (q Query
                   {; optional
                    :args ArgSpec})

ExistsExpr :: (exists Query
                      {; optional
                       :args ArgSpec})

PullExpr :: (pull Query
                  {; optional
                   :args ArgSpec})

PullManyExpr :: (pull* Query
                       {; optional
                        :args ArgSpec})
----

* Call expressions can use functions from the link:../stdlib[XTDB standard library].
* Variable expressions can refer to any variable in scope - within a `unify` clause, any logic variable; within any other operator, any column returned in the previous step.
* Parameter symbols must be prefixed by a `$`; other variables must not start with a `$`.

=== Subqueries

* Subquery expressions must return a single row containing a single column - otherwise, a runtime exception will be thrown.
* 'Exists' expressions will return false if the subquery returns no rows; true otherwise.
* 'Pull' expressions must return a single row - otherwise, a runtime exception will be throws.
The columns in the returned row will be nested into a map in the outer expression.
* 'Pull many' expressions may return any number of rows.
  The rows will be nested into an array of maps in the outer expression.
* The arguments to sub-queries are referred to as parameters in the inner query; no other variables from the outer scope are available in the inner query.

For example:

[source,clojure]
----
(-> (from :posts [{:xt/id $post-id} author-id])
    (with {:author (pull (-> (from :authors [{:xt/id $author-id} post-content])
                             (return :post-content))
                         {:args [author-id]})

           :comments (pull* (-> (from :comments [{:post-id $post-id} comment posted-at])
                                (order-by :posted-at)
                                (limit 2)
                                (return :comment))
                            {:args [{:post-id $post-id}]})})

    (return :post-content :author :comments))

;; =>

{:post-content "..."
 :author {:name "..."}
 :comments [{:comment "..."}, {:comment "..."}]}
----

== Binding specs

[source]
----
BindSpec :: BindVariable | {BindColumn Expr, ...}
BindVariable :: symbol
BindColumn :: keyword
Expr :: <defined separately>
----

Binding specs define which columns are retrieved from a relation, and specify constraints on those columns.

For example:

* We can retrieve columns by listing them:
+
[source,clojure]
----
(from :users [username first-name last-name])

;; i.e. `SELECT username, first_name, last_name FROM users`
----
+
* We can rename columns by specifying a mapping:
+
[source,clojure]
----
(from :users [{:username login} first-name last-name])

;; i.e. `SELECT username AS login, first_name, last_name FROM users`
----
* We can constrain rows by specifying literals or parameters:
+
[source,clojure]
----
(from :users [{:username "james"} first-name last-name])
(from :users [{:username $username} first-name last-name])

;; i.e. `SELECT first_name, last_name FROM users WHERE username = 'james'`
;;      `SELECT first_name, last_name FROM users WHERE username = ?`
----

(In these examples, we use `from` - but the same applies to `join` and `left-join`.)

Within `unify` operators, these output names (`first-name`, `last-name` etc.) create 'logic variables' which, if they are re-used within the same `unify` operator, will add a 'join condition' - see the link:#_unify[`unify`] operator for more details.

== Argument specs

Argument specs are used to fulfil parameters in a sub-query.

[source]
----
ArgSpec :: ArgVariable | {Parameter Expr, ...}
ArgVariable :: symbol
Parameter :: keyword
Expr :: <defined separately>
----

For example:

[source,clojure]
----
;; find the most recent 5 posts and, for each, their most recent 3 comments
(-> (from :posts [{:xt/id post-id, :title post-title, :content post-content} posted-at])
    (with {:comments (pull* (-> (from :comments [{:post-id $post-id} comment commented-at])
                                (order-by {:val commented-at, :dir :desc})
                                (limit 3))
                            {:args [post-id]})})
    (order-by {:val posted-at, :dir :desc})
    (limit 5))

;; find everybody and, for those who have them, their siblings
(-> (unify (from :people [{:xt/id person, :parent parent}])
           (left-join (-> (from :people [{:xt/id sibling, :parent parent}])
                          (where (<> $person sibling)))
                      {:args [person]
                       :bind [sibling parent]}))
    (return :person :sibling))
----
